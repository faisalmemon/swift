// Faisal Memon
// Project Euler problems

// The purpose of this program is to practice using the swift language
// We aim for program clarity and high performance.

/** Return the sum of all multiples less that the supplied limit.

This algorithm uses an arithmetic progression algorithm.
    N*(N+1)/2 = 1 + 2 + 3 + ... + N (arithmetic progression)

therefore
    m * N*(N+1)/2 = m + 2m + 3m + ... + mN

Given some "limit" and some multiple "m",
    (limit - 1) / m gives the upper value we should count to
    assuming integer (rounding down) division

Combining these two ideas is the algorithm we use.

@param  limit       The limit we are count up to, but less than
@param  multiple    The multiple we are summing up
*/
func sumOfMultiples(limit:Int, multiple:Int) ->Int
{
    let arithmetic_N:Int = (limit - 1)/multiple
    
    let result = multiple * arithmetic_N * (arithmetic_N + 1) / 2
    
    return result
}

func eulerProblem_01()
{
    println("Problem 1\n\nIf we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.  Find the sum of all the multiples of 3 or 5 below 1000.\n")
    
    // We count multiples for 3 and 5, but exclude 3*5 multiples as they are already counted
    // in the multiples of 3
    
    let result =
        sumOfMultiples(1000,  3) +
        sumOfMultiples(1000,  5) -
        sumOfMultiples(1000, 15)
    
    println("The answer is \(result).\n")
}

eulerProblem_01()

/** Calculate the next even fibonacci number within a limit.

Methodology:
1) Fibonacci numbers are either odd (o) or even (e) as follows:
o, e, o, o, e,  o, o, e, o, o, e, ... because of the arithmetic
rule:
Odd + Odd = Even
Even + Even = Even
Odd + Even = Odd

2) By do two rounds of fibonacci, we can get from one "e" to the
next "e".  We don't need to bother checking its even.

3) To avoid re-computing past results, we ask for the past 
running total to be supplied, and the past pair of fibonacci 
numbers before doing our two rounds of fibonacci

4) We assume the passed in pair of fibonacci numbers don't exceed
are supplied limit, and on the next even fibonacci we can just test
for exceeding the limit there only.

5) Fibonacci numbers grow very fast (nearly doubling each time).  Since
the next even is found after two iterations, it means we have exponential
growth for the next fibonacci number.  For limit L, we'll find the sum
after O(log(L)) time.

@param  runningTotal    Total of even fibonacci numbers seen so far
@param  upperLimit      Limit number not to exceed the next even fibonacci
@param  n0              First of an adjacent pair of fibonacci numbers with
                        n0 < upperLimit
@param  n1              Next fibonacci number after n1 with n1 < upperLimit

@returns (updatedTotal,n3,n4) where updatedTotal is the supplied runningTotal
         plus the next even fibonacci number not exceeding the supplied
         upperLimit, n3 and n4 are the next pair of fibonacci numbers to be
         supplied for the next call to this method
*/
func sumNextEvenFibonacci(runningTotal:Int, upperLimit:Int, n0:Int, n1:Int) -> (Int, Int, Int)
{
    let n2 = n0 + n1
    let n3 = n2 + n1
    let n4 = n3 + n2
    
    if (n4 < upperLimit)
    {
        return (runningTotal + n4, n3, n4)
    }
    else
    {
        return (runningTotal, n3, n4)
    }
}

func eulerProblem_02()
{
    println("Problem 2\n\nEach new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... \n\nBy considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\n")
    var n0 = 1, n1 = 2, n2 = 0, runningTotal = 2
    do
    {
        (runningTotal, n0, n1) = sumNextEvenFibonacci(runningTotal, 4_000_000, n0, n1)
    } while (n1 < 4_000_000)
    println("The answer is \(runningTotal).\n")
}

eulerProblem_02()

